Author: Stefan Tauner <stefan.tauner@student.tuwien.ac.at>
Description:
 Make dmi_chassis_type aware of the lock bit (Closes: #637028).
 .
 Previously all bits of the parameter passed to dmi_chassis_type were
 used to derive the chassis type although the 7th bit indicates a
 lock and only bits 6:0 encode the chassis type (7.4 System Enclosure
 or Chassis (Type 3), offset 05h). This is ok as long as the input is
 masked as it was done in dmi_decode, but it was forgotten in
 dmi_table_string, resulting in wrong output if there is a lock
 present:
 .
	dmidecode -s chassis-type
	<OUT OF SPEC>
 .
 although the normal output is correct:
 .
	 [...]
	Handle 0x0003, DMI type 3, 17 bytes
	Chassis Information
		Manufacturer: Chassis Manufacture
		Type: Desktop
		Lock: Present
	[...]
 .
 dump (the 5th byte (83) is the interesting one):
 .
	dmidecode -t chassis -u
	SMBIOS 2.3 present.
.
	Handle 0x0003, DMI type 3, 17 bytes
		Header and Data:
			03 11 03 00 01 83 02 03 04 03 03 03 03 01 00 00
			00
.
 Tested with current CVS code on a "Laptop" without a lock (by me)
 and on the "Desktop" board dumped above (by Florian Zumbiehl, thanks!).

diff -Naurp dmidecode.orig/dmidecode.c dmidecode/dmidecode.c
--- dmidecode.orig/dmidecode.c	2011-09-27 21:46:30.569514984 +0200
+++ dmidecode/dmidecode.c	2011-09-28 06:17:27.589536402 +0200
@@ -532,6 +532,7 @@ static const char *dmi_chassis_type(u8 c
 		"Blade Enclosing" /* 0x1D */
 	};
 
+	code &= 0x7F; /* bits 6:0 are chassis type, 7th bit is the lock bit */
 	if (code >= 0x01 && code <= 0x1D)
 		return type[code - 0x01];
 	return out_of_spec;
@@ -3213,7 +3214,7 @@ static void dmi_decode(const struct dmi_
 			printf("\tManufacturer: %s\n",
 				dmi_string(h, data[0x04]));
 			printf("\tType: %s\n",
-				dmi_chassis_type(data[0x05] & 0x7F));
+				dmi_chassis_type(data[0x05]));
 			printf("\tLock: %s\n",
 				dmi_chassis_lock(data[0x05] >> 7));
 			printf("\tVersion: %s\n",
